#include <iostream>
#include <stdio.h>
#include <cstdlib> 
#include <ctime>
#include <sstream>
//#include <iostream>
#include <fstream>
#include <omp.h>

#include "constants.h"
#include "errorcode.h"
#include "PBHpopulation.h"
#include "input.h"
#include "randgen.h"



using namespace std;

int main(int argc, char** argv) {
    
  cout << "************************************** " << endl;	
  cout << "PBH simulator " << endl;
  cout << "************************************** " << endl;
    
  if (argc != 2) {
        cerr << "Usage: ./PBH <xml-file>" << endl;
        exit(-1);
  }

  time_t time_s;
  time_t time_e;

  Input* inp = new Input();
  inp->LoadFile( argv[1] );

  cout << "Parameter file read successfully" << endl;
  inp->Print();
  
  srand(time(NULL));    

  cout << "Constructing the template... " << endl;
  
  ofstream outfile_constraints;
  outfile_constraints.open(mainFile.c_str());
  
  vector<double> massVec;
  double logMass;
  double mass_value;
  logMass = log10(maxPBHMass/minPBHMass) / (numMass-1);
#ifdef POWERLAW
  logMass = log10(maxPBHMassPL/minPBHMassPL) / (numMass-1);
#endif
  cout.precision(10);
  cout << "Mass vector" << endl;
  for (int i=0; i<numMass; i++) {
	  mass_value = pow(10., log10(minPBHMass) + i*logMass );
#ifdef POWERLAW
	  mass_value = pow(10., log10(minPBHMassPL) + i*logMass );
#endif
	  massVec.push_back( mass_value );
	  cout << massVec.back() << "\t";
  }
  cout << endl << endl << endl;
 
  for (int iMass = 0; iMass < numMass; iMass++) {
	  
	  cout << "Now running " << nIterations << " simulations with M = " << massVec[iMass]/mass_sun	 << " and DM fraction = " << DMfraction << endl;
	  cout << lmin/deg << "° < l < " <<  lmax/deg << "° " << endl;
	  
	  stringstream tempString;
	  tempString << histFileBase << iMass << ".dat";
	  string histFileName = tempString.str();
	  ofstream histFile;
	  histFile.open(histFileName.c_str());
	  
	  double nSourcesRadio = 0.;
	  double nSourcesXray = 0.;
	  double sigma2Radio = 0.;
	  double sigma2Xray = 0.;
	  double valuesRadio[nIterations+10]; //+10 to make sure enough space is allocated
	  double valuesXray[nIterations+10]; //idem
	  int valuesFoundByTid[nIterations+10]; //idem (array used to track which thread performed which simulation)
	  valuesFoundByTid[nIterations] = 999; //To clarify the boundary
	  vector<double> radioVels[nIterations+10];
	  vector<double> xrayVels[nIterations+10];
#ifdef SAVEVELIRING
	  vector<vector<double>> RingsVels[nIterations+10];
#endif

	  time(&time_s); // Fix starting time of Monte Carlo

	  // PARALLELIZATION OF FOR LOOP OVER THE ITERATIONS (i.e. parallel monte carlo)
	  #pragma omp parallel for schedule(dynamic)
	  for (int iter = 0; iter < nIterations; iter++) {

		  time_t time_s2;
		  time_t time_e2;		
		  
		  int tid = omp_get_thread_num();
		  //#pragma omp critical
		  //{
		  //cout << "Thread ID #" << tid << " is running simulation #" << iter << endl;
		  //}

		  if (tid == 0) {
		  	cout << "\n=====================================================\n"
			<< "Parallel for loop / Monte Carlo\n" 
			<< "A total of " << omp_get_num_threads() << " threads are running for " << nIterations << " simulations\n"
			<< "Output generated by thread " << tid << ", performing simulation " << iter+1 << "\n"
		  	<< "=====================================================\n" << endl;

			time(&time_s2); // Fix starting time of simulation(s)
		  }
		  valuesFoundByTid[iter] = tid;

		  //PBHpopulation* PBH = new PBHpopulation(inp, lambdaVec[iLambda], etaVec[iEta]);
		  PBHpopulation* PBH = new PBHpopulation(inp, lambdaRicotti, etaFender, massVec[iMass], iter);
		  
		  /*
		  cout << "printing column density... " << endl;
		  PBH->columnDensityPrint(inp);
		  cout << "...done" << endl;
		  return 0;
		  */ 

		  vector<double> value = PBH->runSimulation(inp);
		  valuesRadio[iter] = value[0];//values.push_back(value[0]);=====
		  valuesXray[iter] = value[1];//valuesIonized.push_back(value[1]); =====
		 
                  if (tid == 0) {
                    time(&time_e2); // Fix final time of simulation(s)
                    cout << "Simulation(s) computed in " << (double)(time_e2-time_s2) << " s." << endl;
                  }
 
		  //nSources += value[0];======
		  //nSourcesIonized += value[1]; ======
		  
		  // Retrieving masses only once, namely for iter = 0
		  if (iter == 0) {
			PBH->WriteMassToFile();
		  }		  

		  vector<double> radioVel = PBH->retrievevDetRadio();
		  vector<double> xrayVel = PBH->retrievevDetXray();
		  radioVels[iter] = radioVel;
		  xrayVels[iter] = xrayVel;

#ifdef SAVEVELIRING
		  vector<vector<double>> RingVels = PBH->retrieveVelRings();
		  RingsVels[iter] = RingVels;
#endif

		  delete PBH;	 

//                  #pragma omp ordered
//                  if (tid == 0) cout << "*********************************" << endl;
//                  cout << "Thread #" << tid << ": performed simulation " << iter+1 << endl;

	  }
	  time(&time_e); // Fix final time of Monte Carlo

	  // Writing velocities of detected radio sources to file
          stringstream tempStringVelRad;
          tempStringVelRad << "velocitiesRad_" << massVec[iMass]/mass_sun << ".dat";
          string velFileNameRad = tempStringVelRad.str();
          ofstream velFileRad;
          velFileRad.open(velFileNameRad.c_str());
	  cout << "Writing velocities of radio sources to: " << velFileNameRad << endl;
	  for (int iterV = 0; iterV < nIterations; iterV++) {
		vector<double> vrad = radioVels[iterV];
	  	for(std::vector<double>::iterator it = vrad.begin(); it != vrad.end(); ++it) {
    			velFileRad << *it << endl;
	  	}
	  }
	  velFileRad.close();

          // Writing velocities of detected X-ray sources to file
          stringstream tempStringVelX;
          tempStringVelX << "velocitiesX_" << massVec[iMass]/mass_sun << ".dat";
          string velFileNameX = tempStringVelX.str();
          ofstream velFileX;
          velFileX.open(velFileNameX.c_str());
          cout << "Writing velocities of X-ray sources to: " << velFileNameX << endl;
          for (int iterV = 0; iterV < nIterations; iterV++) {
                vector<double> vx = xrayVels[iterV];
                for(std::vector<double>::iterator it = vx.begin(); it != vx.end(); ++it) {
                        velFileX << *it << endl;
                }
          }
          velFileX.close();

#ifdef SAVEVELIRING
          cout << "Writing velocities of PBHs in each ring to files" << endl;
	  for (int j=0; j<nr-1; j++) { // Loop over the rings
		
		// Creating filename
          	stringstream tempStringVeliRing;
#ifdef EDDPHASESPACE
          	tempStringVeliRing << "velocitiesiRingEd_" << j << ".dat";
#endif
#ifdef MAXWELLIANS
          	tempStringVeliRing << "velocitiesiRingMB_" << j << ".dat";
#endif
#if !defined(EDDPHASESPACE) && !defined(MAXWELLIANS)
          	tempStringVeliRing << "velocitiesiRing_" << j << ".dat";
#endif
          	string velFileNameiRing = tempStringVeliRing.str();

		
          	ofstream velFileiRing;
          	velFileiRing.open(velFileNameiRing.c_str(), std::ofstream::app);
          	//cout << "Writing velocities of PBHs in iRing to: " << velFileNameiRing << endl;
          	for (int iterV = 0; iterV < nIterations; iterV++) {
                	vector<double> viRing = RingsVels[iterV][j];
                	for(std::vector<double>::iterator it = viRing.begin(); it != viRing.end(); ++it) {
                        	velFileiRing << *it << endl;
                	}
          	}
          	velFileiRing.close();
	  }
#endif

          cout << "\nMonte Carlo computed in " << (double)(time_e-time_s) << " s." << endl;

	  for (int iter = 0; iter < nIterations; iter++) {
		nSourcesRadio += valuesRadio[iter];
		nSourcesXray += valuesXray[iter];
		histFile << valuesRadio[iter] << "\t" << valuesXray[iter] << " obtained by tid no " << valuesFoundByTid[iter] << endl;
	  }
  	
	  nSourcesRadio /= nIterations;
	  nSourcesXray /= nIterations;
		  
	  for (int iter = 0; iter < nIterations; iter++) { 
	  	sigma2Radio += ( pow(valuesRadio[iter] - nSourcesRadio, 2.)  );
		sigma2Xray += ( pow(valuesXray[iter] - nSourcesXray, 2.)  );
	  }

	  sigma2Radio /= (nIterations-1);
	  sigma2Xray /= (nIterations-1);

	  histFile.close();

  	  outfile_constraints << DMfraction << "\t" << massVec[iMass]/mass_sun << "\t" << nSourcesRadio << "\t" << sqrt(sigma2Radio) << "\t" << nSourcesXray << "\t" << sqrt(sigma2Xray) << endl;
  	  
  }
    
  outfile_constraints.close();
  
  //cout << "Saving the template" << endl;    
  //PBH->WriteToFile();
  //PBH->RadioWriteToFile();

  delete inp;

  return 0;

}
